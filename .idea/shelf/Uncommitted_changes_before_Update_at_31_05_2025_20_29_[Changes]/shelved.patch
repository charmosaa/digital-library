Index: app.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># app.py\r\nimport os\r\nfrom flask import Flask, render_template, request, redirect, url_for, flash\r\nfrom dotenv import load_dotenv\r\nimport requests\r\nfrom models import db, Book, Category \r\n\r\nload_dotenv()\r\n\r\napp = Flask(__name__)\r\n\r\n# --- App Configuration and Database ---\r\napp.config['SECRET_KEY'] = os.getenv('SECRET_KEY')\r\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///site.db'\r\napp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False\r\n\r\ndb.init_app(app)\r\n\r\n# --- Application Views (Routes) ---\r\n@app.route('/')\r\ndef home():\r\n    status_filter = request.args.get('status_filter')\r\n    only_favorites = request.args.get('only_favorites') == '1'\r\n\r\n    query = Book.query\r\n\r\n    if status_filter in ['0', '1', '2']:\r\n        query = query.filter_by(status=int(status_filter))\r\n\r\n    if only_favorites:\r\n        query = query.filter_by(is_favorite=True)\r\n\r\n    books = query.all()\r\n\r\n    total_books = Book.query.count()\r\n    to_read_count = Book.query.filter_by(status=0).count()\r\n    reading_count = Book.query.filter_by(status=1).count()\r\n    read_count = Book.query.filter_by(status=2).count()\r\n\r\n    return render_template(\r\n        'home.html',\r\n        books=books,\r\n        status_filter=status_filter,\r\n        only_favorites=only_favorites,\r\n        total_books=total_books,\r\n        to_read_count=to_read_count,\r\n        reading_count=reading_count,\r\n        read_count=read_count\r\n    )\r\n\r\n\r\n@app.route('/add_book', methods=['GET', 'POST'])\r\ndef add_book():\r\n    if request.method == 'POST':\r\n        title = request.form['title']\r\n        author = request.form['author']\r\n        category_id = request.form.get('category_id') # Can be None\r\n        \r\n        new_book = Book(title=title, author=author)\r\n        if category_id:\r\n            new_book.category_id = category_id\r\n        \r\n        db.session.add(new_book)\r\n        db.session.commit()\r\n        flash('Book added successfully!', 'success')\r\n        return redirect(url_for('home'))\r\n    \r\n    categories = Category.query.all()\r\n    return render_template('add_book.html', categories=categories)\r\n\r\n# --- Search Books with default popular results ---\r\n@app.route('/search', methods=['GET', 'POST'])\r\ndef search_books():\r\n    query = request.args.get('query', '').strip() # Get query, default to empty string, strip whitespace\r\n    books_from_api = []\r\n    \r\n    # Base URL for Google Books API\r\n    base_api_url = \"https://www.googleapis.com/books/v1/volumes?\"\r\n    \r\n    if query:\r\n        # If a query is provided, search specifically for it\r\n        api_url = f\"{base_api_url}q={query}&printType=books&maxResults=20\"\r\n        title_text = f\"Search results for '{query}'\"\r\n    else:\r\n        # If no query, show some popular/random books\r\n        # 'q=bestsellers' or 'q=fiction' are good general terms\r\n        # For a more \"random\" feel, you could use a few different default queries\r\n        api_url = f\"{base_api_url}q=bestsellers&printType=books&maxResults=20\" \r\n        title_text = \"Browse Popular Books\"\r\n    \r\n    try:\r\n        response = requests.get(api_url)\r\n        response.raise_for_status() # Raise HTTPError for bad responses (4xx or 5xx)\r\n        data = response.json()\r\n        \r\n        if 'items' in data:\r\n            for item in data['items']:\r\n                volume_info = item.get('volumeInfo', {})\r\n                \r\n                title = volume_info.get('title', 'No Title')\r\n                authors = volume_info.get('authors', ['No Author'])\r\n                author = ', '.join(authors)\r\n                \r\n                description = volume_info.get('description', 'No description available.')\r\n                published_date = volume_info.get('publishedDate', 'No Date')\r\n                page_count = volume_info.get('pageCount')\r\n                \r\n                image_links = volume_info.get('imageLinks', {})\r\n                thumbnail = image_links.get('thumbnail') or image_links.get('smallThumbnail')\r\n                \r\n                isbn_13 = None\r\n                industry_identifiers = volume_info.get('industryIdentifiers', [])\r\n                for identifier in industry_identifiers:\r\n                    if identifier.get('type') == 'ISBN_13':\r\n                        isbn_13 = identifier.get('identifier')\r\n                        break\r\n\r\n                books_from_api.append({\r\n                    'title': title,\r\n                    'author': author,\r\n                    'description': description,\r\n                    'published_date': published_date,\r\n                    'page_count': page_count,\r\n                    'thumbnail': thumbnail,\r\n                    'isbn': isbn_13,\r\n                    'google_books_id': item.get('id')\r\n                })\r\n        else:\r\n            if query: # Only flash if user actually searched and found nothing\r\n                flash(\"No books found for your query.\", 'info')\r\n            else: # For default browse, just display empty results\r\n                flash(\"Could not fetch popular books. Try searching!\", 'info')\r\n\r\n    except requests.exceptions.RequestException as e:\r\n        flash(f\"An error occurred while communicating with the API: {e}\", 'danger')\r\n    except ValueError: # JSON decoding error\r\n        flash(\"Error parsing data from API. Please try again.\", 'danger')\r\n    \r\n    return render_template('search_results.html', books=books_from_api, query=query, title_text=title_text)\r\n\r\n# --- Add Book from API to Collection ---\r\n@app.route('/add_from_api', methods=['POST'])\r\ndef add_from_api():\r\n    title = request.form['title']\r\n    author = request.form['author']\r\n    isbn = request.form.get('isbn')\r\n    description = request.form.get('description')\r\n    year_published_str = request.form.get('published_date')\r\n    page_count_str = request.form.get('page_count')\r\n    cover_url = request.form.get('cover_url')\r\n\r\n    year_published = None\r\n    if year_published_str:\r\n        try:\r\n            year_published = int(year_published_str[:4])\r\n        except (ValueError, TypeError):\r\n            pass\r\n    \r\n    page_count = None\r\n    if page_count_str:\r\n        try:\r\n            page_count = int(page_count_str)\r\n        except (ValueError, TypeError):\r\n            pass\r\n\r\n    try:\r\n        existing_book = None\r\n        if isbn:\r\n            existing_book = Book.query.filter_by(isbn=isbn).first()\r\n\r\n        if existing_book:\r\n            flash(f'Book \"{title}\" (ISBN: {isbn}) is already in your collection!', 'info')\r\n        else:\r\n            new_book = Book(\r\n                title=title,\r\n                author=author,\r\n                isbn=isbn,\r\n                description=description,\r\n                year_published=year_published,\r\n                page_count=page_count,\r\n                cover_url=cover_url,\r\n                is_favorite=False,\r\n                status=0 # Default to \"To Read\"\r\n\r\n            )\r\n            db.session.add(new_book)\r\n            db.session.commit()\r\n            flash(f'Book \"{title}\" has been added to your collection!', 'success')\r\n    except Exception as e:\r\n        flash(f\"An error occurred while adding the book: {e}\", 'danger')\r\n\r\n    return redirect(url_for('home'))\r\n\r\n# --- Delete Book Route ---\r\n@app.route('/remove_book/<int:book_id>', methods=['POST'])\r\ndef remove_book(book_id):\r\n    book_to_delete = Book.query.get_or_404(book_id)\r\n    try:\r\n        db.session.delete(book_to_delete)\r\n        db.session.commit()\r\n        flash(f'Book \"{book_to_delete.title}\" removed from your shelf.', 'success')\r\n    except Exception as e:\r\n        db.session.rollback() # Rollback in case of an error\r\n        flash(f\"Error removing book: {e}\", 'danger')\r\n    return redirect(url_for('home'))\r\n\r\n\r\n@app.route('/toggle_favorite/<int:book_id>', methods=['POST'])\r\ndef toggle_favorite(book_id):\r\n    book = Book.query.get_or_404(book_id)\r\n    book.is_favorite = not book.is_favorite\r\n    try:\r\n        db.session.commit()\r\n        status = \"added to\" if book.is_favorite else \"removed from\"\r\n        flash(f'Book \"{book.title}\" {status} favorites.', 'success')\r\n    except Exception as e:\r\n        db.session.rollback()\r\n        flash(f\"Error updating favorite status: {e}\", 'danger')\r\n    return redirect(url_for('home'))\r\n\r\n\r\n\r\n\r\n# --- Edit Book Route ---\r\n@app.route('/edit_book/<int:book_id>', methods=['GET', 'POST'])\r\ndef edit_book(book_id):\r\n    book = Book.query.get_or_404(book_id)\r\n    categories = Category.query.all()\r\n\r\n    if request.method == 'POST':\r\n        try:\r\n            # ONLY update category, status, and current_page\r\n            \r\n            # Handle category\r\n            category_id = request.form.get('category_id')\r\n            book.category_id = int(category_id) if category_id else None\r\n\r\n            # Handle status\r\n            new_status = int(request.form.get('status'))\r\n            book.status = new_status\r\n\r\n            # Handle current_page based on new_status\r\n            if new_status == 1: # If status is \"Reading\"\r\n                current_page_str = request.form.get('current_page')\r\n                book.current_page = int(current_page_str) if current_page_str else 0\r\n            else: # If status is not \"Reading\", reset current_page\r\n                book.current_page = None\r\n\r\n            db.session.commit()\r\n            flash(f'Book \"{book.title}\" updated successfully!', 'success')\r\n            return redirect(url_for('home'))\r\n        except ValueError:\r\n            db.session.rollback()\r\n            flash(\"Invalid input for current page. Please enter a valid number.\", 'danger')\r\n        except Exception as e:\r\n            db.session.rollback()\r\n            flash(f\"An error occurred while updating the book: {e}\", 'danger')\r\n    \r\n    # For GET request, render the form with existing book data\r\n    return render_template('edit_book.html', book=book, categories=categories)\r\n\r\n\r\n\r\nif __name__ == '__main__':\r\n    app.run(debug=True)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app.py b/app.py
--- a/app.py	(revision 88d2e676cd0228d95b0939437c18da7b4a094379)
+++ b/app.py	(date 1748716047573)
@@ -3,7 +3,7 @@
 from flask import Flask, render_template, request, redirect, url_for, flash
 from dotenv import load_dotenv
 import requests
-from models import db, Book, Category 
+from models import db, Book, Category
 
 load_dotenv()
 
@@ -17,7 +17,7 @@
 db.init_app(app)
 
 # --- Application Views (Routes) ---
-@app.route('/')
+@app.route('/', methods=['GET'])
 def home():
     status_filter = request.args.get('status_filter')
     only_favorites = request.args.get('only_favorites') == '1'
@@ -219,10 +219,8 @@
     return redirect(url_for('home'))
 
 
-
-
 # --- Edit Book Route ---
-@app.route('/edit_book/<int:book_id>', methods=['GET', 'POST'])
+@app.route('/edit_book/<int:book_id>', methods=['GET'])
 def edit_book(book_id):
     book = Book.query.get_or_404(book_id)
     categories = Category.query.all()
